## 树中的专业术语
1. 节点（Node）：树中的基本元素，每个节点都包含数据和一个或多个子节点指针。
2. 根节点（Root）：树的顶端节点，没有父节点，所有其他节点都从根节点分支出来。
3. 子节点（Child）：从某个节点延伸出的节点，子节点是指向该节点的指针的拥有者。
4. 父节点（Parent）：指向子节点的节点，父节点是子节点指针的来源。
5. 兄弟节点（Sibling）：共享同一父节点的节点，它们在树结构中处于同一层级。
6. 叶子节点（Leaf）：没有子节点的节点，也称为终端节点或外部节点。
7. 内部节点（Internal Node）：有至少一个子节点的节点，不是叶子节点。
8. **节点的度**（Degree）：一个节点拥有的子节点数。
9. **树的高度**（Height）：树的高度是根节点到最远叶子节点的最长路径上的边数。
10. 平衡树（Balanced Tree）：树的高度大约是节点数的对数，例如AVL树或红黑树。
11. **深度**（Depth）：节点的深度是从根节点到该节点的路径上的边数。
12. 路径（Path）：从一个节点到另一个节点的序列，其中包含它们之间的边。
13. 祖先（Ancestor）：在树中，如果一个节点包含另一个节点，那么前者就是后者的祖先。
14. 子孙（Descendant）：在树中，如果一个节点是另一个节点的子节点，那么后者就是前者的子孙。
15. **森林**（Forest）：由多个树组成的集合，每个树都是独立的，没有共享的节点。
16. **树的重心**（Centroid）：树中一个节点的子树大小与其他所有非根子树大小之和相等，这个节点就是树的重心。
17. 最小值节点（Minimum）：在二叉搜索树中，最小值节点是最左边的节点。
18. 最大值节点（Maximum）：在二叉搜索树中，最大值节点是最右边的节点。


## 二叉搜索树（BST）
这个是最早接触的树，也是最简单的树结构，是一颗**非平衡二叉树**。
我觉得它就可以简单理解成==二分搜索的结构化体现==：
- 有一个**根节点**（类似于二分搜索的中点）
- 节点的**左孩子**的值一定小于节点的值
- 节点的**右孩子**的值一定大于节点的值

由于BST不用维护树，所以它是最简单的树。

先说下它的节点的实现吧：
```cpp
struct Node {
	int val;
	Node* left_child;
	Node* right_child;
};
```
非常的简单明了。
而它的插入操作也很简单，就是一直顺着找，看看它应该放在哪个位置，==该位置一定是一个叶子节点==：
```cpp
void insert(int val, Node* root) {
	// 从根节点
}
```

## 二叉平衡树（AVL）

## Splay树
这是在准备竞赛的时候学到的一种全新的数据结构，它是一种**平衡二叉搜索树**，它的主要思想就是==将最近访问过的元素移动到树的根部==。这就是它最具特色的**Splay操作**，使用左旋和右旋完成；同时，在完成了Splay之后，二叉树的性质并不会发生改变：中序遍历的输入仍旧是由小到大的排序，节点与左右孩子的关系也依旧没有改变……它所改变的只是树的结构。
那么，什么时候我们需要使用Splay操作呢？根据它的定义，对元素访问之后就要进行Splay操作，故：==插入之后需要Splay；对元素进行访问之后也需要Splay操作==。也正是因为Splay树需要频繁进行旋转操作更改树的结构，它的效率也被拉低了。

它的原理让我想到了[[../计算机系统基础/存储器层次结构#程序的局部性|程序的局部性]]，事实也确实如此，Splay树利用了程序的**空间局部性**，也就是==刚被访问过的元素很可能马上会被再次访问==。
关于左旋和右旋在[[#二叉平衡树（AVL）|AVL]]中已经提及了，这里就不多说了，此处仅仅对Splay这一关键操作进行一个实现：
```cpp
void Splay() {

}
```