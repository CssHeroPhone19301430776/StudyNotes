在[[存储器层次结构]]中，已经初步提及了缓存这一概念。![[img/缓存/i7缓存架构.png]]
在上图中提及了CPU核心中的缓存器结构，其中需要了解两个：**Data-Cache（D-Cache)和Instruction-Cache(I-Cache）**，它们分别于用于数据存放和指令存放，更具体的在下图中：![[img/缓存/无序处理器结构.png]]

## 高速缓存存储器
而在CPU中，就有一类非常重要的缓存，即**高速缓存存储器**（Cache Memories）。它包含在CPU芯片中，==完全由硬件管理==，由**SRAM**存储器实现。![[img/缓存/高速缓存存储器.png]]
而这个处于寄存器附近的缓存的实质是：==存储主存储器中，经常访问的块==，由于程序具有[[存储器层次结构#程序的局部性|局部性原则]]，因此大多数数据都会从缓存中提取，这一提取操作只需要花费几个**时钟周期**，比直接从主存储器中提取数据要快捷的多。

## 缓存的组织（构建）
缓存中有三种结构：**块**、**组**、**行**，==块所存在的目的就是：利用局部性原则来分摊数据（使得更多的近期可能需要访问的数据在缓存中能找到，而减少访问主存储器的次数），以此降低数据获取的成本==
![[img/缓存/缓存的组织.png]]
缓存的结构如上如所示。
- 在每一行（line）中，存在一个**有效位**（Valid bit），==指示这些数据位和数据块实际上是存在的==，在第一次打开数据的时候，缓存中并没有数据，但是他们中存储了随机比特位，但是这些数据并没有用。
- 而**标志位**（Tag）则是用于帮助我们找到块的附加位

## 缓存中数据的读取（**需要看书**）
![[img/缓存/缓存中数据的读取.png]]
当程序访问（执行指令）的时候，会引用主存中的一些<font color="sky-blue">字这个名词还是第一次见）</font>，CPU将这个字的地址发送到缓存，询问并要求该地址返回字，因此缓存占用该地址。
在64-x86机器中，==地址是64位的，并划分为多个区域==，如何划分由缓存的构建决定，也就是上图所示。
- b：用于确定块中的偏移量，该位置就是数据字开始的地方
- s：==被视为无符号整型==，它是组的索引
- t：构成了line中的标签位

> [!读取流程]
  所以，如果我们需要的数据字在缓存中，它会存在与s表示的组中；
  然后它检查标记位，检查行中是否有任何匹配的标记；
  再检查有效位是否为1；
  最后使用低b位来确定数据字的位置。

==如果找到了这一组、这一行，但是Tag不匹配，那么程序就需要从主存储器中获取数据，并在行中覆盖此块==。

<font color="red"><b>疑惑：</b></font>
1. CPU所需的内存的数据地址和传入缓存的数据地址之间有什么联系？
2. 传入缓存的数据地址中的**偏移量**的作用是什么？是不是偏移量之后的该块中的所有数据都是CPU需要的？CPU如何确定自己需要哪些？

<font color="red"><b>解答：</b></font>
1. 在本课程中，我们是假设缓存知道需要提取多大的数据，所以不要考虑哪些数据是CPU需要的
2. 而偏移量的作用就是确定数据在块中的起始地址
3. 内存地址和传入缓存的地址有着某种**映射关系**，这是由缓存控制器的算法决定的

#### 缓存读取示例
下面这个示例已经把缓存拆分了，它是以组为最大单位的：
![[img/缓存/缓存读取示例.png]]

## 数据写入
数据写入有两种方式：
1. 直接将数据写入到内存中，但是效率很低
2. 将数据写入缓存中的块，当块需要被替换的时候（并且块中的数据发生了改变）才需要重新写回内存

在第二种方式下，需要一个额外的位来标识该块中的数据是否发生了修改，因为只有被修改了的数据才需要更新。